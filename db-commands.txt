Mongodb->Database-->Collection--->Document
MySQL->Database-->Table--->Record(RowNColumn)

CRUD Operations
===============
#Insert many records with unordered style
db.emp.insertMany([{"_id":9,"fname":"Kush","lname":"Raghani"},{"_id":10,"fname":John,"lname":"Thomas"},{"_id":11,"fname":"Anmol","lname":"Patil"}])

#Insert many records with unordered style
db.emp.insertMany([{"_id":9,"fname":"Kush","lname":"Raghani"},{"_id":10,"fname":John,"lname":"Thomas"},{"_id":11,"fname":"Anmol","lname":"Patil"}],{ ordered:false})

#simple for loop to insert many records
for ( i=12; i<=50; i++ ) { db.emp.insert({"_id":i,"fname":"test_"+i,"lname":"test_"+i}) }

#Delete one line
db.emp.deleteOne({"_id":10})
db.emp.deleteOne({"fname":"Anmol"})		----> it will delete very first match

#Delete many
db.emp.deleteMany({"_id":{ $gt : 30 }})
db.emp.deleteMany({"fname":"Anmol"}) 	----> it will delete all match
db.emp.deleteMany({})		-----> it will delete all documents from that collection

#Drop collection
db.emp.drop()

#Drop Database
db.dropDatabase()

Indexing
=========
#Priority for Indexing
Single Field Index
Compound Field Index (max 33 (0-32))
Text Index
Multikey Index  (index on array)
Hashed Index    (generally used in sharding)
Partial Index


queryparser - before doing anything checking query syntax and will confirm everything is fine and will try to find what about query is

explain(), expain("executionstats"), explain("allPlansExecution")
queryplanner
winningplan
rejectedplan
executionstats (should read from bottom to top)
allPlansExecution


#Replication
--------------
Adventages
1) Provide Failover
2) Security
3)

Disadvantages
--------------
1) NO scalable at WRITE
2) Primary get overloaded, if secondary goes offline

How replication work
---------------------
client app --> Primary DB <--- Secondary DB

Client app will write data on oplog of primary db, and then secondary db will read from oplog of primary db.

Oplog -> operation log is capped collection

Note - In oplog replication, it do statement based replication.

Replication type
------------------
1) From Primary replication (all secondary will read from primary)
2) Chain replication (second secondary will read from first secondary, and first secondary will read from primary db)

States of replication
----------------------
startup state (initial sync run)
secondary node state

Below point IMP in case of election
-----------------------------------
vote
    1 enable
    0 disable
priority
    more number, more priority

If priority not given then, votting will happen, and Primary DB get selected.

IMP NOTE - In 2 SLAVE server, election will not happen. At lease 3 nodes should be there for election.

Max 50 (49+1) member can be in replication set. All 50 members can not vote. Only 12 member can vote.